<!DOCTYPE html>

<html>
<head>
  <title>main</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="http://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
        
        
        <li id="section-1">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="require">Require</h1>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A Node.js compatible require implementation for pure client side apps.</p>
<p>Each file is a module. Modules are responsible for exporting an object. Unlike
traditional client side JavaScript, Ruby, or other common languages the module
is not responsible for naming its product in the context of the requirer. This
maintains encapsulation because it is impossible from within a module to know
what external name would be correct to prevent errors of composition in all
possible uses.</p>
<h2 id="definitions">Definitions</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h3 id="module">Module</h3>
<p>A module is a file.</p>
<h3 id="package">Package</h3>
<p>A package is an aggregation of modules. A package is a json object with the
following properties:</p>
<ul>
<li><code>distribution</code> An object whose keys are paths and properties are <code>fileData</code></li>
<li><code>entryPoint</code> Path to the primary module that requiring this package will require.</li>
<li><code>dependencies</code> An object whose keys are names and whose values are packages.</li>
</ul>
<p>It may have additional properties such as <code>source</code>, <code>repository</code>, and <code>docs</code>.</p>
<h3 id="application">Application</h3>
<p>An application is a package which has an <code>entryPoint</code> and may have dependencies.
Additionally an application&#39;s dependencies may have dependencies. Dependencies
must be bundled with the package.</p>
<h2 id="uses">Uses</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>From a module require another module in the same package.</p>
<blockquote>
<pre><code>require &quot;./soup&quot;</code></pre>
</blockquote>
<p>Require a module in the parent directory</p>
<blockquote>
<pre><code>require &quot;../nuts&quot;</code></pre>
</blockquote>
<p>Require a module from the root directory in the same package.</p>
<p>NOTE: This could behave slightly differently under Node.js if your package does
not have it&#39;s own jailed filesystem.</p>
<blockquote>
<pre><code>require &quot;/silence&quot;</code></pre>
</blockquote>
<p>From a module within a package, require a dependent package.</p>
<blockquote>
<pre><code>require &quot;console&quot;</code></pre>
</blockquote>
<p>The dependency will be delcared something like</p>
<blockquote>
<pre><code>dependencies:
  console: &quot;http://strd6.github.io/console/v1.2.2.json&quot;</code></pre>
</blockquote>
<h2 id="implementation">Implementation</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>File separator is &#39;/&#39;</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">fileSeparator = <span class="string">'/'</span></code></pre>
</div>
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>In the browser <code>global</code> is <code>window</code>.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">global = window</code></pre>
</div>
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Default entry point</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">defaultEntryPoint = <span class="string">"main"</span></code></pre>
</div>
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>A sentinal against circular requires.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">circularGuard = {}</code></pre>
</div>
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>A top-level module so that all other modules won&#39;t have to be orphans.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">rootModule =
  path: <span class="string">""</span></code></pre>
</div>
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Require a module given a path within a package. Each file is its own separate
module. An application is composed of packages.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">loadPath</span></span> = (parentModule, pkg, path) -&gt;
  <span class="keyword">if</span> startsWith(path, <span class="string">'/'</span>)
    localPath = []
  <span class="keyword">else</span>
    localPath = parentModule.path.split(fileSeparator)

  normalizedPath = normalizePath(path, localPath)

  cache = cacheFor(pkg)

  <span class="keyword">if</span> module = cache[normalizedPath]
    <span class="keyword">if</span> module <span class="keyword">is</span> circularGuard
      <span class="keyword">throw</span> <span class="string">"Circular dependency detected when requiring <span class="subst">#{normalizedPath}</span>"</span>
  <span class="keyword">else</span>
    cache[normalizedPath] = circularGuard

    <span class="keyword">try</span>
      cache[normalizedPath] = module = loadModule(pkg, normalizedPath)
    <span class="keyword">finally</span>
      <span class="keyword">delete</span> cache[normalizedPath] <span class="keyword">if</span> cache[normalizedPath] <span class="keyword">is</span> circularGuard

  <span class="keyword">return</span> module.exports</code></pre>
</div>
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>To normalize the path we convert local paths to a standard form that does not
contain an references to current or parent directories.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">normalizePath</span></span> = (path, base=[]) -&gt;
  base = base.concat path.split(fileSeparator)
  result = []</code></pre>
</div>
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Chew up all the pieces into a standardized path.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">  <span class="keyword">while</span> base.length
    <span class="keyword">switch</span> piece = base.shift()
      <span class="keyword">when</span> <span class="string">".."</span>
        result.pop()
      <span class="keyword">when</span> <span class="string">""</span>, <span class="string">"."</span>
        <span class="comment"># Skip</span>
      <span class="keyword">else</span>
        result.push(piece)

  <span class="keyword">return</span> result.join(fileSeparator)</code></pre>
</div>
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><code>loadPackage</code> Loads a dependent package at that packages entry point.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">loadPackage</span></span> = (parentModule, pkg) -&gt;
  path = pkg.entryPoint <span class="keyword">or</span> defaultEntryPoint

  loadPath(parentModule, pkg, path)</code></pre>
</div>
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Load a file from within a package.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">loadModule</span></span> = (pkg, path) -&gt;
  <span class="keyword">unless</span> (file = pkg.distribution[path])
    <span class="keyword">throw</span> <span class="string">"Could not find file at <span class="subst">#{path}</span> in <span class="subst">#{pkg.name}</span>"</span>

  program = file.content
  dirname = path.split(fileSeparator)[<span class="number">0.</span>..-<span class="number">1</span>].join(fileSeparator)

  module =
    path: dirname
    exports: {}</code></pre>
</div>
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>This external context provides some variable that modules have access to.</p>
<p>A <code>require</code> function is exposed to modules so they may require other modules.</p>
<p>Additional properties such as a reference to the global object and some metadata
are also exposed.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">  context =
    require: generateRequireFn(pkg, module)
    global: global
    module: module
    exports: module.exports
    PACKAGE: pkg
    __filename: path
    __dirname: dirname

  args = Object.keys(context)
  values = args.map (name) -&gt; context[name]</code></pre>
</div>
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Execute the program within the module and given context.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">  Function(args..., program).apply(module, values)

  <span class="keyword">return</span> module</code></pre>
</div>
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Helper to detect if a given path is a package.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">isPackage</span></span> = (path) -&gt;
  <span class="keyword">if</span> !(startsWith(path, fileSeparator) <span class="keyword">or</span>
    startsWith(path, <span class="string">".<span class="subst">#{fileSeparator}</span>"</span>) <span class="keyword">or</span>
    startsWith(path, <span class="string">"..<span class="subst">#{fileSeparator}</span>"</span>)
  )
    path.split(fileSeparator)[<span class="number">0</span>]
  <span class="keyword">else</span>
    <span class="literal">false</span></code></pre>
</div>
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Generate a require function for a given module in a package.</p>
<p>If we are loading a package in another module then we strip out the module part
of the name and use the <code>rootModule</code> rather than the local module we came from.
That way our local path won&#39;t affect the lookup path in another package.</p>
<p>Loading a module within our package, uses the requiring module as a parent for
local path resolution.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">generateRequireFn</span></span> = (pkg, module=rootModule) -&gt;
  pkg.name ?= <span class="string">"ROOT"</span>

  (path) -&gt;
    <span class="keyword">if</span> isPackage(path)
      <span class="keyword">unless</span> otherPackage = pkg.dependencies[path]
        <span class="keyword">throw</span> <span class="string">"Package: <span class="subst">#{path}</span> not found."</span>

      otherPackage.name ?= path

      loadPackage(rootModule, otherPackage)
    <span class="keyword">else</span>
      loadPath(module, pkg, path)</code></pre>
</div>
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Because we can&#39;t actually <code>require(&#39;require&#39;)</code> we need to export it a little
differently.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="keyword">if</span> exports?
  exports.generateFor = generateRequireFn
<span class="keyword">else</span>
  global.Require =
    generateFor: generateRequireFn</code></pre>
</div>
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2 id="notes">Notes</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>We have to use <code>pkg</code> as a variable name because <code>package</code> is a reserved word.</p>
<p>Node needs to check file extensions, but because we only load compiled products
we never have extensions in our path.</p>
<p>So while Node may need to check for either <code>path/somefile.js</code> or <code>path/somefile.coffee</code>
that will already have been resolved for us and we will only check <code>path/somefile</code></p>
<p>Circular dependencies are not allowed and raise an exception when detected.</p>
<h2 id="helpers">Helpers</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Detect if a string starts with a given prefix.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">startsWith</span></span> = (string, prefix) -&gt;
  string.lastIndexOf(prefix, <span class="number">0</span>) <span class="keyword">is</span> <span class="number">0</span></code></pre>
</div>
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Creates a cache for modules within a package. It uses <code>defineProperty</code> so that
the cache doesn&#39;t end up being enumerated or serialized to json.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">cacheFor</span></span> = (pkg) -&gt;
  <span class="keyword">return</span> pkg.cache <span class="keyword">if</span> pkg.cache

  Object.defineProperty pkg, <span class="string">"cache"</span>,
    value: {}

  <span class="keyword">return</span> pkg.cache</code></pre>
</div>
        </li>
        
    </ul>
  </div>
  <script src="//code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script>
<script src="http://strd6.github.io/require/v0.2.2.js"></script><script>
  $.ajax({
    url: "http://strd6.github.io/interactive/v0.8.1.jsonp",
    dataType: "jsonp",
    jsonpCallback: "STRd6/interactive:v0.8.1",
    cache: true
  }).then(function(PACKAGE) {
    Require.generateFor(PACKAGE)("./" + PACKAGE.entryPoint)
  })
</script><script src="package.js"></script>
</body>
</html>